<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood-Based Pixel Art Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* This is crucial for maintaining the pixelated look when scaled */
        .image-rendering-pixelated {
            image-rendering: optimizeSpeed;             /* Older versions of FF */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+ */
            image-rendering: -webkit-optimize-contrast; /* Safari, Chrome */
            image-rendering: optimize-contrast;         /* CSS4 */
            image-rendering: pixelated;                 /* CSS4 */
            -ms-interpolation-mode: nearest-neighbor;   /* IE */
        }
        .suggestions-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 8px 8px;
            background-color: white;
            z-index: 10;
            position: absolute; /* To position it directly below the input */
            width: calc(100% - 2rem); /* Match input width with padding */
            left: 1rem; /* Match input padding */
            right: 1rem;
        }
        .suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            text-align: left;
            border-bottom: 1px solid #edf2f7;
        }
        .suggestion-item:last-child {
            border-bottom: none;
        }
        .suggestion-item:hover {
            background-color: #f7fafc;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const App = () => {
            const [moodInput, setMoodInput] = React.useState('');
            const [pixelArtDataUrl, setPixelArtDataUrl] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);
            const [isDrawingAnimating, setIsDrawingAnimating] = React.useState(false);
            const [errorMessage, setErrorMessage] = React.useState('');
            const [affirmation, setAffirmation] = React.useState('');
            const [isAffirmationLoading, setIsAffirmationLoading] = React.useState(false);
            const [llmConcept, setLlmConcept] = React.useState('');
            const [llmPalette, setLlmPalette] = React.useState([]);
            const [artDescription, setArtDescription] = React.useState('');
            const [isDescriptionLoading, setIsDescriptionLoading] = React.useState(false);
            const [selectedArtStyle, setSelectedArtStyle] = React.useState('All');
            const [selectedPixelSize, setSelectedPixelSize] = React.useState(10);
            const [moodIntensity, setMoodIntensity] = React.useState(50);

            // New states for mood suggestions
            const [showSuggestions, setShowSuggestions] = React.useState(false);
            const [filteredSuggestions, setFilteredSuggestions] = React.useState([]);

            const canvasRef = React.useRef(null);
            const artContainerRef = React.useRef(null);
            const moodInputRef = React.useRef(null); // Ref for mood input
            const [canvasSize, setCanvasSize] = React.useState(400);

            // Click outside to close suggestions
            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (moodInputRef.current && !moodInputRef.current.contains(event.target)) {
                        setShowSuggestions(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, [moodInputRef]);


            React.useEffect(() => {
                const updateCanvasSize = () => {
                    if (artContainerRef.current) {
                        const containerWidth = artContainerRef.current.offsetWidth;
                        const newSize = Math.min(400, Math.floor(containerWidth * 0.9));
                        setCanvasSize(newSize);
                    }
                };

                updateCanvasSize();
                window.addEventListener('resize', updateCanvasSize);

                return () => window.removeEventListener('resize', updateCanvasSize);
            }, []);

            const positiveAffirmations = React.useMemo(() => [
                "You are capable of amazing things.", "Every day is a new opportunity to shine.",
                "Your strength is greater than any struggle.", "Believe in yourself and all that you are.",
                "You are worthy of happiness and success.", "Embrace the journey, enjoy the growth.",
                "Today is a gift, that's why it's called the present.", "Your potential is limitless.",
                "You are a beacon of positive energy.", "Great things are coming your way."
            ], []);

            // New list of mood suggestions for autocompletion
            const moodSuggestions = React.useMemo(() => [
                "happy", "joyful", "calm", "peaceful", "energetic", "creative", "excited",
                "hopeful", "relaxed", "serene", "tranquil", "playful", "bright", "lively",
                "focused", "thoughtful", "balanced", "structured", "harmonious", "dreamy",
                "wonder", "curious", "imaginative", "renewed", "restful", "vibrant", "powerful",
                "fresh", "growth", "new beginnings", "optimistic", "strong", "inspired", "grateful"
            ], []);

            const positiveArtConceptsAndPalettes = React.useMemo(() => [
                {
                    concept: "A vibrant abstract pattern of swirling colors, evoking a sense of light and freedom.",
                    palette: ["#FFD700", "#FFA500", "#87CEEB", "#90EE90", "#FF69B4"],
                    moodTags: ["energetic", "happy", "joyful", "creative", "excited", "vibrant"],
                    style: "Abstract",
                    drawType: "random_pixels"
                },
                {
                    concept: "A serene landscape with a rising sun, bringing warmth and new beginnings.",
                    palette: ["#FFCC33", "#FF9900", "#66CCFF", "#99FF99", "#FFCCCC"],
                    moodTags: ["calm", "peaceful", "hopeful", "relaxed", "serene", "tranquil", "new beginnings"],
                    style: "Nature",
                    drawType: "horizontal_stripes"
                },
                {
                    concept: "A cheerful, pixelated garden bursting with happy flowers and bright skies.",
                    palette: ["#FFCC00", "#FF6666", "#66FF66", "#33CCFF", "#FF99CC"],
                    moodTags: ["happy", "joyful", "playful", "bright", "lively", "nature"],
                    style: "Nature",
                    drawType: "random_pixels"
                },
                {
                    concept: "An uplifting abstract design with geometric shapes and harmonious gradients.",
                    palette: ["#ADD8E6", "#87CEEB", "#6495ED", "#4682B4", "#7B68EE"],
                    moodTags: ["calm", "focused", "thoughtful", "balanced", "structured", "harmonious"],
                    style: "Geometric",
                    drawType: "checkerboard"
                },
                {
                    concept: "A playful scene of stars twinkling in a peaceful night sky, full of wonder.",
                    palette: ["#F0E68C", "#DAA520", "#4682B4", "#7B68EE", "#DDA0DD"],
                    moodTags: ["dreamy", "wonder", "calm", "curious", "imaginative", "peaceful"],
                    style: "Abstract",
                    drawType: "random_pixels"
                },
                {
                    concept: "A burst of positive energy, represented by dynamic lines and contrasting bright colors.",
                    palette: ["#FF4500", "#FFD700", "#ADFF2F", "#00BFFF", "#FF1493"],
                    moodTags: ["energetic", "excited", "dynamic", "bold", "vibrant", "powerful"],
                    style: "Abstract",
                    drawType: "vertical_stripes"
                },
                {
                    concept: "A tranquil ocean view at sunrise, promoting peace and renewal.",
                    palette: ["#87CEFA", "#6A5ACD", "#B0E0E6", "#FFDAB9", "#F08080"],
                    moodTags: ["peaceful", "calm", "tranquil", "renewed", "restful", "serene"],
                    style: "Nature",
                    drawType: "horizontal_stripes"
                },
                {
                    concept: "Abstract patterns reminiscent of a blooming spring, vibrant and fresh.",
                    palette: ["#7CFC00", "#32CD32", "#FFC0CB", "#FFD700", "#9370DB"],
                    moodTags: ["fresh", "growth", "happy", "vibrant", "new beginnings", "natural"],
                    style: "Abstract",
                    drawType: "random_pixels"
                },
                 {
                    concept: "A cityscape at dawn, with hopeful light breaking through.",
                    palette: ["#A9A9A9", "#778899", "#ADD8E6", "#FFD700", "#FF6347"],
                    moodTags: ["hopeful", "urban", "new beginnings", "optimistic", "modern"],
                    style: "Geometric",
                    drawType: "checkerboard"
                },
                // NEW ALGORITHMS AND CONCEPTS
                {
                    concept: "Dynamic diagonal lines conveying motion and progress.",
                    palette: ["#FF6347", "#FFD700", "#00BFFF", "#7B68EE", "#ADFF2F"],
                    moodTags: ["dynamic", "progress", "active", "forward-looking", "energetic"],
                    style: "Abstract",
                    drawType: "diagonal_lines"
                },
                {
                    concept: "Concentric squares expanding from the center, representing focus and expansion.",
                    palette: ["#6495ED", "#FFDAB9", "#90EE90", "#FF99CC", "#87CEEB"],
                    moodTags: ["focused", "expanding", "meditative", "growth", "balanced"],
                    style: "Geometric",
                    drawType: "concentric_squares"
                },
                {
                    concept: "A calm, almost cosmic noise pattern, suggesting peace in complexity.",
                    palette: ["#DDA0DD", "#B0E0E6", "#6A5ACD", "#4682B4", "#778899"],
                    moodTags: ["calm", "contemplative", "peaceful", "complex", "cosmic"],
                    style: "Abstract",
                    drawType: "noise_pattern"
                }
            ], []);

            const artStyles = React.useMemo(() => [
                'All',
                ...new Set(positiveArtConceptsAndPalettes.map(item => item.style))
            ], [positiveArtConceptsAndPalettes]);

            const hexToColorName = React.useMemo(() => ({
                "#FFD700": "Gold", "#FFA500": "Orange", "#87CEEB": "Sky Blue", "#90EE90": "Light Green", "#FF69B4": "Hot Pink",
                "#FFCC33": "Golden Yellow", "#FF9900": "Orange", "#66CCFF": "Light Blue", "#99FF99": "Mint Green", "#FFCCCC": "Light Pink",
                "#FFCC00": "Yellow", "#FF6666": "Red-Orange", "#66FF66": "Bright Green", "#33CCFF": "Cerulean", "#FF99CC": "Pink",
                "#ADD8E6": "Light Blue", "#6495ED": "Cornflower Blue", "#4682B4": "Steel Blue", "#7B68EE": "Medium Slate Blue",
                "#F0E68C": "Khaki", "#DAA520": "Goldenrod", "#DDA0DD": "Plum", "#FF4500": "Orange Red", "#ADFF2F": "Green Yellow",
                "#00BFFF": "Deep Sky Blue", "#FF1493": "Deep Pink", "#87CEFA": "Light Sky Blue", "#6A5ACD": "Slate Blue",
                "#B0E0E6": "Powder Blue", "#FFDAB9": "Peach Puff", "#F08080": "Light Coral", "#7CFC00": "Lawn Green",
                "#32CD32": "Lime Green", "#FFC0CB": "Pink", "#9370DB": "Medium Purple", "#A9A9A9": "Dark Gray",
                "#778899": "Light Slate Gray", "#FF6347": "Tomato"
            }), []);

            const drawPixelArt = React.useCallback((canvas, concept, palette, pixelSize, drawType, moodIntensity, animate = true) => {
                const ctx = canvas.getContext('2d');
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                const sortedPalette = [...palette].sort((a, b) => {
                    const hexToRgb = hex => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return r + g + b;
                    };
                    return hexToRgb(b) - hexToRgb(a);
                });

                const effectivePalette = sortedPalette.slice(0, Math.max(1, Math.floor(sortedPalette.length * (moodIntensity / 100))));
                if (effectivePalette.length === 0) effectivePalette.push(sortedPalette[0]);

                const backgroundColor = effectivePalette[0];
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const pixelsToDraw = [];

                const addPixel = (x, y, color, alpha = 1.0) => {
                    pixelsToDraw.push({ x, y, color, alpha });
                };

                switch (drawType) {
                    case "horizontal_stripes":
                        for (let y = 0; y < canvasHeight; y += pixelSize) {
                            const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                            for (let x = 0; x < canvasWidth; x += pixelSize) {
                                addPixel(x, y, color);
                            }
                        }
                        break;
                    case "vertical_stripes":
                        for (let x = 0; x < canvasWidth; x += pixelSize) {
                            const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                            for (let y = 0; y < canvasHeight; y += pixelSize) {
                                addPixel(x, y, color);
                            }
                        }
                        break;
                    case "checkerboard":
                        for (let y = 0; y < canvasHeight; y += pixelSize) {
                            for (let x = 0; x < canvasWidth; x += pixelSize) {
                                const colorIndex = ((x / pixelSize) + (y / pixelSize)) % effectivePalette.length;
                                addPixel(x, y, effectivePalette[colorIndex]);
                            }
                        }
                        break;
                    case "diagonal_lines":
                        const numLines = Math.floor(canvasWidth / pixelSize / 4); // Number of diagonal segments
                        for (let i = 0; i < numLines; i++) {
                            const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                            const startX = i * pixelSize * 4;
                            const startY = 0;
                            for (let offset = 0; ; offset++) {
                                const x = startX + offset * pixelSize;
                                const y = startY + offset * pixelSize;
                                if (x >= canvasWidth || y >= canvasHeight) break;
                                addPixel(x, y, color);
                            }
                            const startX2 = 0;
                            const startY2 = i * pixelSize * 4;
                            for (let offset = 0; ; offset++) {
                                const x = startX2 + offset * pixelSize;
                                const y = startY2 + offset * pixelSize;
                                if (x >= canvasWidth || y >= canvasHeight) break;
                                addPixel(x, y, color);
                            }
                        }
                        break;
                    case "concentric_squares":
                        const maxDim = Math.max(canvasWidth, canvasHeight);
                        const numSquares = Math.floor(maxDim / (pixelSize * 4)); // Adjust spacing of squares
                        for (let i = 0; i < numSquares; i++) {
                            const color = effectivePalette[i % effectivePalette.length];
                            const currentSize = (i + 1) * pixelSize * 4;
                            const startX = (canvasWidth - currentSize) / 2;
                            const startY = (canvasHeight - currentSize) / 2;

                            if (startX < 0 || startY < 0) continue; // Avoid drawing outside canvas

                            // Top horizontal line
                            for (let x = startX; x < startX + currentSize; x += pixelSize) {
                                addPixel(x, startY, color);
                            }
                            // Bottom horizontal line
                            for (let x = startX; x < startX + currentSize; x += pixelSize) {
                                addPixel(x, startY + currentSize - pixelSize, color);
                            }
                            // Left vertical line
                            for (let y = startY; y < startY + currentSize; y += pixelSize) {
                                addPixel(startX, y, color);
                            }
                            // Right vertical line
                            for (let y = startY; y < startY + currentSize; y += pixelSize) {
                                addPixel(startX + currentSize - pixelSize, y, color);
                            }
                        }
                        break;
                    case "noise_pattern":
                        for (let y = 0; y < canvasHeight; y += pixelSize) {
                            for (let x = 0; x < canvasWidth; x += pixelSize) {
                                if (Math.random() > 0.3) { // Density of noise
                                    const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                                    addPixel(x, y, color, 0.5 + Math.random() * 0.5); // Vary alpha for "grainy" effect
                                }
                            }
                        }
                        break;
                    case "random_pixels":
                    default:
                        for (let y = 0; y < canvasHeight; y += pixelSize) {
                            for (let x = 0; x < canvasWidth; x += pixelSize) {
                                const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                                if (Math.random() > 0.6) {
                                    addPixel(x, y, color);
                                }
                            }
                        }
                        const numShapes = Math.floor(Math.random() * 3) + 2;
                        for (let i = 0; i < numShapes; i++) {
                            const shapeColor = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                            const startX = Math.floor(Math.random() * (canvasWidth / pixelSize)) * pixelSize;
                            const startY = Math.floor(Math.random() * (canvasHeight / pixelSize)) * pixelSize;
                            const shapeWidth = Math.floor(Math.random() * (canvasWidth / pixelSize / 4) + 1) * pixelSize;
                            const shapeHeight = Math.floor(Math.random() * (canvasHeight / pixelSize / 4) + 1) * pixelSize;

                            if (Math.random() > 0.5) {
                                for (let px = startX; px < startX + shapeWidth; px += pixelSize) {
                                    for (let py = startY; py < startY + shapeHeight; py += pixelSize) {
                                        addPixel(px, py, shapeColor, 0.6 + Math.random() * 0.3);
                                    }
                                }
                            } else {
                                const radius = Math.min(shapeWidth, shapeHeight) / 2;
                                for (let px = startX; px < startX + radius * 2; px += pixelSize) {
                                    for (let py = startY; py < startY + radius * 2; py += pixelSize) {
                                        addPixel(px, py, shapeColor, 0.6 + Math.random() * 0.3);
                                    }
                                }
                            }
                        }
                        break;
                }

                pixelsToDraw.sort(() => Math.random() - 0.5);

                if (animate) {
                    setIsDrawingAnimating(true);
                    let index = 0;
                    const pixelsPerFrame = Math.max(1, Math.floor(pixelsToDraw.length / 20));

                    const animateDrawing = () => {
                        const endIndex = Math.min(index + pixelsPerFrame, pixelsToDraw.length);
                        for (let i = index; i < endIndex; i++) {
                            const p = pixelsToDraw[i];
                            ctx.globalAlpha = p.alpha || 1.0;
                            ctx.fillStyle = p.color;
                            ctx.fillRect(p.x, p.y, pixelSize, pixelSize);
                        }
                        index = endIndex;
                        if (index < pixelsToDraw.length) {
                            requestAnimationFrame(animateDrawing);
                        } else {
                            setPixelArtDataUrl(canvas.toDataURL('image/png'));
                            ctx.globalAlpha = 1.0;
                            setIsDrawingAnimating(false);
                        }
                    };
                    requestAnimationFrame(animateDrawing);
                } else {
                    pixelsToDraw.forEach(p => {
                        ctx.globalAlpha = p.alpha || 1.0;
                        ctx.fillStyle = p.color;
                        ctx.fillRect(p.x, p.y, pixelSize, pixelSize);
                    });
                    ctx.globalAlpha = 1.0;
                    setPixelArtDataUrl(canvas.toDataURL('image/png'));
                }
            }, [setIsDrawingAnimating, setPixelArtDataUrl]);


            const generateAffirmation = React.useCallback(async () => {
                setIsAffirmationLoading(true);
                setAffirmation('');
                setErrorMessage('');

                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const randomAffirmation = positiveAffirmations[Math.floor(Math.random() * positiveAffirmations.length)];
                    setAffirmation(randomAffirmation);
                } catch (error) {
                    console.error('Error generating affirmation:', error);
                    setErrorMessage(`Error generating affirmation: ${error.message || 'Something went wrong.'}`);
                } finally {
                    setIsAffirmationLoading(false);
                }
            }, [positiveAffirmations]);

            const generateArt = React.useCallback(async (isSurprise = false) => { // Added isSurprise parameter
                setIsLoading(true);
                setPixelArtDataUrl('');
                setArtDescription('');
                setErrorMessage('');
                setLlmConcept('');
                setLlmPalette([]);
                setShowSuggestions(false); // Hide suggestions when generating art

                try {
                    await new Promise(resolve => setTimeout(resolve, 500));

                    let availableArt = positiveArtConceptsAndPalettes;

                    if (selectedArtStyle !== 'All') {
                        availableArt = availableArt.filter(item => item.style === selectedArtStyle);
                    }

                    let finalArtData = null;

                    if (isSurprise || !moodInput.trim()) { // If Surprise button or mood input is empty
                        finalArtData = availableArt[Math.floor(Math.random() * availableArt.length)];
                    } else {
                        let bestMatch = null;
                        let maxScore = -1;
                        const lowerCaseMoodWords = moodInput.toLowerCase().split(/\s+/).filter(word => word.length > 0);

                        if (lowerCaseMoodWords.length > 0) {
                            for (const artItem of availableArt) {
                                let currentScore = 0;
                                for (const moodTag of artItem.moodTags) {
                                    if (lowerCaseMoodWords.includes(moodTag)) {
                                        currentScore++;
                                    }
                                }
                                if (currentScore > maxScore) {
                                    maxScore = currentScore;
                                    bestMatch = artItem;
                                }
                            }
                        }
                        finalArtData = bestMatch || availableArt[Math.floor(Math.random() * availableArt.length)];
                    }

                    if (!finalArtData) {
                         setErrorMessage("No art concepts available for the selected style. Try a different mood or 'All' styles.");
                         return;
                    }

                    const concept = finalArtData.concept;
                    const palette = finalArtData.palette;
                    const drawType = finalArtData.drawType || "random_pixels";

                    setLlmConcept(concept);
                    setLlmPalette(palette);

                    const canvas = canvasRef.current;
                    if (canvas) {
                        drawPixelArt(canvas, concept, palette, selectedPixelSize, drawType, moodIntensity, true);
                    } else {
                        throw new Error('Canvas element not found. This should not happen as canvas is always rendered.');
                    }

                } catch (error) {
                    console.error('Error generating art:', error);
                    setErrorMessage(`Error: ${error.message || 'Something went wrong during art generation. Please try again.'}`);
                } finally {
                    setIsLoading(false);
                }
            }, [moodInput, selectedArtStyle, selectedPixelSize, moodIntensity, positiveArtConceptsAndPalettes, drawPixelArt]);

            const generateSurpriseArt = React.useCallback(() => {
                setMoodInput(''); // Clear mood input to ensure random selection if not already empty
                generateArt(true); // Call generateArt with the surprise flag
            }, [generateArt]);

            const describeArt = React.useCallback(async () => {
                setIsDescriptionLoading(true);
                setArtDescription('');
                setErrorMessage('');

                try {
                    await new Promise(resolve => setTimeout(resolve, 700));

                    if (!llmConcept || llmPalette.length === 0) {
                        throw new Error('No art concept or palette available to describe. Please generate art first.');
                    }

                    const colorNames = llmPalette.map(hex => hexToColorName[hex] || hex);
                    
                    const description = `This pixel art is based on the concept: "${llmConcept}". It uses a vibrant palette of colors including ${colorNames.join(', ')}, designed to evoke feelings of positivity and joy.`;
                    setArtDescription(description);

                } catch (error) {
                    console.error('Error describing art:', error);
                    setErrorMessage(`Error describing art: ${error.message || 'Something went wrong.'}`);
                } finally {
                    setIsDescriptionLoading(false);
                }
            }, [llmConcept, llmPalette, hexToColorName]);

            const downloadArt = React.useCallback(() => {
                if (pixelArtDataUrl) {
                    const link = document.createElement('a');
                    link.href = pixelArtDataUrl;
                    link.download = `mood_pixel_art_${Date.now()}.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else {
                    setErrorMessage("No pixel art to download. Please generate some art first!");
                }
            }, [pixelArtDataUrl]);

            const resetApp = React.useCallback(() => {
                setMoodInput('');
                setPixelArtDataUrl('');
                setIsLoading(false);
                setIsDrawingAnimating(false);
                setErrorMessage('');
                setAffirmation('');
                setIsAffirmationLoading(false);
                setLlmConcept('');
                setLlmPalette([]);
                setArtDescription('');
                setIsDescriptionLoading(false);
                setSelectedArtStyle('All');
                setSelectedPixelSize(10);
                setMoodIntensity(50);
                setShowSuggestions(false);
                setFilteredSuggestions([]);
            }, []);

            // Handle mood input changes for suggestions
            const handleMoodInputChange = (e) => {
                const value = e.target.value;
                setMoodInput(value);
                if (value.trim().length > 0) {
                    const currentWords = value.toLowerCase().split(/\s+/).filter(word => word.length > 0);
                    const lastWord = currentWords[currentWords.length - 1];
                    const newSuggestions = moodSuggestions.filter(suggestion =>
                        suggestion.startsWith(lastWord) && !currentWords.includes(suggestion)
                    );
                    setFilteredSuggestions(newSuggestions);
                    setShowSuggestions(newSuggestions.length > 0);
                } else {
                    setShowSuggestions(false);
                }
            };

            // Handle clicking on a suggestion
            const handleSuggestionClick = (suggestion) => {
                const currentWords = moodInput.split(/\s+/).filter(word => word.length > 0);
                if (currentWords.length > 0) {
                    currentWords[currentWords.length - 1] = suggestion; // Replace last word
                    setMoodInput(currentWords.join(' ') + ' '); // Add space for next word
                } else {
                    setMoodInput(suggestion + ' ');
                }
                setShowSuggestions(false); // Hide suggestions after selection
                moodInputRef.current.focus(); // Keep focus on input
            };


            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-100 to-blue-200 flex items-center justify-center p-4 font-sans">
                    <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-2xl text-center border border-gray-200">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6 tracking-tight">
                            Mood-Inspired Pixel Art
                        </h1>
                        <p className="text-gray-600 mb-8 text-lg leading-relaxed">
                            Tell me how you're feeling, and I'll create a unique piece of uplifting pixel art with colors chosen to boost your mood!
                        </p>

                        {/* Mood Input Section */}
                        <div className="mb-6 relative" ref={moodInputRef}> {/* Added ref here */}
                            <label htmlFor="mood" className="block text-gray-700 text-xl font-semibold mb-3">
                                How are you feeling right now?
                            </label>
                            <input
                                id="mood"
                                type="text"
                                value={moodInput}
                                onChange={handleMoodInputChange} // Use new handler
                                onFocus={() => { // Show suggestions on focus if input has text
                                    if (moodInput.trim().length > 0) {
                                        const currentWords = moodInput.toLowerCase().split(/\s+/).filter(word => word.length > 0);
                                        const lastWord = currentWords[currentWords.length - 1];
                                        const newSuggestions = moodSuggestions.filter(suggestion =>
                                            suggestion.startsWith(lastWord) && !currentWords.includes(suggestion)
                                        );
                                        setFilteredSuggestions(newSuggestions);
                                        setShowSuggestions(newSuggestions.length > 0);
                                    }
                                }}
                                placeholder="e.g., Anxious, Happy, Tired, Creative..."
                                className="w-full p-4 border border-gray-300 rounded-lg focus:ring-4 focus:ring-blue-300 focus:border-blue-500 transition duration-200 text-lg text-gray-800"
                            />
                            {showSuggestions && filteredSuggestions.length > 0 && (
                                <ul className="suggestions-list absolute w-full mt-1 bg-white border border-gray-200 rounded-lg shadow-lg max-h-48 overflow-y-auto z-10">
                                    {filteredSuggestions.map((suggestion) => (
                                        <li
                                            key={suggestion}
                                            className="p-3 text-left hover:bg-gray-100 cursor-pointer text-gray-700 text-base"
                                            onClick={() => handleSuggestionClick(suggestion)}
                                        >
                                            {suggestion}
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>

                        {/* Mood Intensity Slider */}
                        <div className="mb-6">
                            <label htmlFor="mood-intensity" className="block text-gray-700 text-xl font-semibold mb-3">
                                Mood Intensity: {moodIntensity}%
                            </label>
                            <input
                                id="mood-intensity"
                                type="range"
                                min="0"
                                max="100"
                                step="1"
                                value={moodIntensity}
                                onChange={(e) => setMoodIntensity(parseInt(e.target.value))}
                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-green-500"
                            />
                            <div className="flex justify-between text-gray-500 text-sm mt-2">
                                <span>Subtle</span>
                                <span>Vibrant</span>
                            </div>
                        </div>

                        {/* Art Style Selection */}
                        <div className="mb-6">
                            <label htmlFor="art-style" className="block text-gray-700 text-xl font-semibold mb-3">
                                Choose an Art Style:
                            </label>
                            <select
                                id="art-style"
                                value={selectedArtStyle}
                                onChange={(e) => setSelectedArtStyle(e.target.value)}
                                className="w-full p-4 border border-gray-300 rounded-lg focus:ring-4 focus:ring-purple-300 focus:border-purple-500 transition duration-200 text-lg text-gray-800"
                            >
                                {artStyles.map(style => (
                                    <option key={style} value={style}>{style}</option>
                                ))}
                            </select>
                        </div>

                        {/* Pixel Size Control */}
                        <div className="mb-8">
                            <label htmlFor="pixel-size" className="block text-gray-700 text-xl font-semibold mb-3">
                                Pixelation Level (Smaller = More Detail): {selectedPixelSize}px
                            </label>
                            <input
                                id="pixel-size"
                                type="range"
                                min="2"
                                max="20"
                                step="1"
                                value={selectedPixelSize}
                                onChange={(e) => setSelectedPixelSize(parseInt(e.target.value))}
                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500"
                            />
                            <div className="flex justify-between text-gray-500 text-sm mt-2">
                                <span>More Detail</span>
                                <span>More Pixelated</span>
                            </div>
                        </div>

                        {/* Affirmation Button */}
                        <button
                            onClick={generateAffirmation}
                            disabled={isAffirmationLoading || isLoading || !moodInput.trim()}
                            className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mb-4
                                ${isAffirmationLoading
                                    ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-green-500 to-teal-600 text-white shadow-md hover:shadow-lg'
                                }`}
                        >
                            {isAffirmationLoading ? (
                                <span className="flex items-center justify-center">
                                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Generating Affirmation...
                                </span>
                            ) : (
                                '✨ Get Affirmation'
                            )}
                        </button>

                        {/* Display Affirmation */}
                        {affirmation && (
                            <div className="mt-4 mb-6 p-4 bg-blue-50 border border-blue-200 text-blue-800 rounded-lg text-left italic">
                                <p className="font-semibold">Your Affirmation:</p>
                                <p>"{affirmation}"</p>
                            </div>
                        )}

                        {/* Canvas element is now always rendered, but hidden */}
                        <canvas
                            ref={canvasRef}
                            width={canvasSize}
                            height={canvasSize}
                            style={{ display: 'none' }}
                        ></canvas>

                        {/* Generate Art Buttons */}
                        <div className="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                            <button
                                onClick={() => generateArt(false)}
                                disabled={isLoading || isDrawingAnimating || !moodInput.trim()}
                                className={`flex-1 py-4 px-6 rounded-lg text-xl font-bold transition duration-300 ease-in-out transform hover:scale-105
                                    ${isLoading || isDrawingAnimating || !moodInput.trim()
                                        ? 'bg-gradient-to-r from-gray-400 to-gray-500 text-gray-200 cursor-not-allowed'
                                        : 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg hover:shadow-xl'
                                    }`}
                            >
                                {(isLoading || isDrawingAnimating) ? (
                                    <span className="flex items-center justify-center">
                                        <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                        {isDrawingAnimating ? 'Drawing Pixel Art...' : 'Generating Concept...'}
                                    </span>
                                ) : (
                                    'Generate My Mood Art'
                                )}
                            </button>
                            <button
                                onClick={generateSurpriseArt}
                                disabled={isLoading || isDrawingAnimating}
                                className={`flex-1 py-4 px-6 rounded-lg text-xl font-bold transition duration-300 ease-in-out transform hover:scale-105
                                    ${isLoading || isDrawingAnimating
                                        ? 'bg-gradient-to-r from-gray-400 to-gray-500 text-gray-200 cursor-not-allowed'
                                        : 'bg-gradient-to-r from-orange-500 to-yellow-600 text-white shadow-lg hover:shadow-xl'
                                    }`}
                            >
                                {(isLoading || isDrawingAnimating) ? (
                                    <span className="flex items-center justify-center">
                                        <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                        Surprising You...
                                    </span>
                                ) : (
                                    '🎲 Surprise Me!'
                                )}
                            </button>
                        </div>


                        {/* Error Message Display */}
                        {errorMessage && (
                            <div className="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg text-left">
                                <p className="font-semibold">Oops! Something went wrong:</p>
                                <p>{errorMessage}</p>
                            </div>
                        )}

                        {/* Generated Art Display */}
                        {pixelArtDataUrl && (
                            <div className="mt-10 border-t border-gray-200 pt-8" ref={artContainerRef}>
                                <h2 className="text-3xl font-bold text-gray-800 mb-6">Your Uplifting Pixel Art</h2>
                                <div className="bg-gray-100 p-2 rounded-lg shadow-inner flex justify-center">
                                    <img
                                        src={pixelArtDataUrl}
                                        alt="Generated Pixel Art"
                                        style={{ width: `${canvasSize}px`, height: `${canvasSize}px`, imageRendering: 'pixelated' }}
                                        className="max-w-full rounded-lg shadow-md image-rendering-pixelated"
                                        onError={(e) => {
                                            e.target.onerror = null;
                                            e.target.src = "https://placehold.co/400x400/FF0000/FFFFFF?text=Pixel+Art+Load+Error";
                                            setErrorMessage("Failed to load generated pixel art. It might be corrupted or missing.");
                                        }}
                                    />
                                </div>
                                <p className="text-gray-500 text-sm mt-4">
                                    This art was generated to evoke positive feelings using a palette based on color psychology.
                                </p>

                                {/* Action Buttons */}
                                <div className="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                                    {/* Regenerate Button */}
                                    <button
                                        onClick={() => generateArt(false)}
                                        disabled={isLoading || isDrawingAnimating}
                                        className={`flex-1 py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105
                                            ${isLoading || isDrawingAnimating
                                                ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                                : 'bg-gradient-to-r from-pink-500 to-red-600 text-white shadow-md hover:shadow-lg'
                                            }`}
                                    >
                                        {isLoading || isDrawingAnimating ? (
                                            <span className="flex items-center justify-center">
                                                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                {isDrawingAnimating ? 'Drawing New Art...' : 'Generating New Concept...'}
                                            </span>
                                        ) : (
                                            '🔄 Regenerate Art'
                                        )}
                                    </button>

                                    {/* Download Art Button */}
                                    <button
                                        onClick={downloadArt}
                                        disabled={!pixelArtDataUrl || isLoading || isDrawingAnimating}
                                        className={`flex-1 py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105
                                            ${!pixelArtDataUrl || isLoading || isDrawingAnimating
                                                ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                                : 'bg-gradient-to-r from-blue-500 to-green-600 text-white shadow-md hover:shadow-lg'
                                            }`}
                                    >
                                        ⬇️ Download Art
                                    </button>
                                </div>

                                {/* Describe Art Button */}
                                <button
                                    onClick={describeArt}
                                    disabled={isDescriptionLoading || isLoading || isDrawingAnimating || !llmConcept || llmPalette.length === 0}
                                    className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mt-4
                                        ${isDescriptionLoading || isLoading || isDrawingAnimating
                                            ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                            : 'bg-gradient-to-r from-indigo-500 to-purple-700 text-white shadow-md hover:shadow-lg'
                                            }`}
                                >
                                    {isDescriptionLoading ? (
                                        <span className="flex items-center justify-center">
                                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Describing Art...
                                        </span>
                                    ) : (
                                        '✨ Describe Pixel Art'
                                    )}
                                </button>

                                {/* Display Art Description */}
                                {artDescription && (
                                    <div className="mt-4 p-4 bg-purple-50 border border-purple-200 text-purple-800 rounded-lg text-left">
                                        <p className="font-semibold">AI Art Description:</p>
                                        <p>{artDescription}</p>
                                    </div>
                                )}
                            </div>
                        )}
                        {/* Reset Button */}
                        <button
                            onClick={resetApp}
                            className="w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mt-8 bg-gray-200 text-gray-700 shadow-md hover:shadow-lg hover:bg-gray-300"
                        >
                            Reset App
                        </button>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
