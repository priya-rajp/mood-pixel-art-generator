<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood-Based Pixel Art Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* This is crucial for maintaining the pixelated look when scaled */
        .image-rendering-pixelated {
            image-rendering: optimizeSpeed;             /* Older versions of FF */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+ */
            image-rendering: -webkit-optimize-contrast; /* Safari, Chrome */
            image-rendering: optimize-contrast;         /* CSS4 */
            image-rendering: pixelated;                 /* CSS4 */
            -ms-interpolation-mode: nearest-neighbor;   /* IE */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const App = () => {
            const [moodInput, setMoodInput] = React.useState('');
            const [pixelArtDataUrl, setPixelArtDataUrl] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false); // General loading for art generation
            const [isDrawingAnimating, setIsDrawingAnimating] = React.useState(false); // Specific for drawing animation
            const [errorMessage, setErrorMessage] = React.useState('');
            const [affirmation, setAffirmation] = React.useState('');
            const [isAffirmationLoading, setIsAffirmationLoading] = React.useState(false);
            const [llmConcept, setLlmConcept] = React.useState('');
            const [llmPalette, setLlmPalette] = React.useState([]);
            const [artDescription, setArtDescription] = React.useState('');
            const [isDescriptionLoading, setIsDescriptionLoading] = React.useState(false);
            const [selectedArtStyle, setSelectedArtStyle] = React.useState('All'); // New state for art style filter

            const canvasRef = React.useRef(null);

            // --- Predefined Data for Local Generation ---

            const positiveAffirmations = React.useMemo(() => [
                "You are capable of amazing things.",
                "Every day is a new opportunity to shine.",
                "Your strength is greater than any struggle.",
                "Believe in yourself and all that you are.",
                "You are worthy of happiness and success.",
                "Embrace the journey, enjoy the growth.",
                "Today is a gift, that's why it's called the present.",
                "Your potential is limitless.",
                "You are a beacon of positive energy.",
                "Great things are coming your way."
            ], []);

            const positiveArtConceptsAndPalettes = React.useMemo(() => [
                {
                    concept: "A vibrant abstract pattern of swirling colors, evoking a sense of light and freedom.",
                    palette: ["#FFD700", "#FFA500", "#87CEEB", "#90EE90", "#FF69B4"],
                    moodTags: ["energetic", "happy", "joyful", "creative"],
                    style: "Abstract"
                },
                {
                    concept: "A serene landscape with a rising sun, bringing warmth and new beginnings.",
                    palette: ["#FFCC33", "#FF9900", "#66CCFF", "#99FF99", "#FFCCCC"],
                    moodTags: ["calm", "peaceful", "hopeful", "relaxed", "serene"],
                    style: "Nature"
                },
                {
                    concept: "A cheerful, pixelated garden bursting with happy flowers and bright skies.",
                    palette: ["#FFCC00", "#FF6666", "#66FF66", "#33CCFF", "#FF99CC"],
                    moodTags: ["happy", "joyful", "playful", "bright"],
                    style: "Nature"
                },
                {
                    concept: "An uplifting abstract design with geometric shapes and harmonious gradients.",
                    palette: ["#ADD8E6", "#87CEEB", "#6495ED", "#4682B4", "#7B68EE"],
                    moodTags: ["calm", "focused", "thoughtful", "balanced"],
                    style: "Geometric"
                },
                {
                    concept: "A playful scene of stars twinkling in a peaceful night sky, full of wonder.",
                    palette: ["#F0E68C", "#DAA520", "#4682B4", "#7B68EE", "#DDA0DD"],
                    moodTags: ["dreamy", "wonder", "calm", "curious"],
                    style: "Abstract" // Categorizing as abstract for general style
                },
                {
                    concept: "A burst of positive energy, represented by dynamic lines and contrasting bright colors.",
                    palette: ["#FF4500", "#FFD700", "#ADFF2F", "#00BFFF", "#FF1493"],
                    moodTags: ["energetic", "excited", "dynamic", "bold"],
                    style: "Abstract"
                },
                {
                    concept: "A tranquil ocean view at sunrise, promoting peace and renewal.",
                    palette: ["#87CEFA", "#6A5ACD", "#B0E0E6", "#FFDAB9", "#F08080"], // Light Sky Blue, Slate Blue, Powder Blue, Peach Puff, Light Coral
                    moodTags: ["peaceful", "calm", "tranquil", "renewed"],
                    style: "Nature"
                },
                {
                    concept: "Abstract patterns reminiscent of a blooming spring, vibrant and fresh.",
                    palette: ["#7CFC00", "#32CD32", "#FFC0CB", "#FFD700", "#9370DB"], // Lawn Green, Lime Green, Pink, Gold, Medium Purple
                    moodTags: ["fresh", "growth", "happy", "vibrant"],
                    style: "Abstract"
                },
                 {
                    concept: "A cityscape at dawn, with hopeful light breaking through.",
                    palette: ["#A9A9A9", "#778899", "#ADD8E6", "#FFD700", "#FF6347"], // Dark Gray, Light Slate Gray, Light Blue, Gold, Tomato
                    moodTags: ["hopeful", "urban", "new beginnings"],
                    style: "Geometric"
                }
            ], []);

            const artStyles = React.useMemo(() => [
                'All',
                ...new Set(positiveArtConceptsAndPalettes.map(item => item.style))
            ], [positiveArtConceptsAndPalettes]);

            const hexToColorName = React.useMemo(() => ({
                "#FFD700": "Gold", "#FFA500": "Orange", "#87CEEB": "Sky Blue", "#90EE90": "Light Green", "#FF69B4": "Hot Pink",
                "#FFCC33": "Golden Yellow", "#FF9900": "Orange", "#66CCFF": "Light Blue", "#99FF99": "Mint Green", "#FFCCCC": "Light Pink",
                "#FFCC00": "Yellow", "#FF6666": "Red-Orange", "#66FF66": "Bright Green", "#33CCFF": "Cerulean", "#FF99CC": "Pink",
                "#ADD8E6": "Light Blue", "#6495ED": "Cornflower Blue", "#4682B4": "Steel Blue", "#7B68EE": "Medium Slate Blue",
                "#F0E68C": "Khaki", "#DAA520": "Goldenrod", "#DDA0DD": "Plum", "#FF4500": "Orange Red", "#ADFF2F": "Green Yellow",
                "#00BFFF": "Deep Sky Blue", "#FF1493": "Deep Pink", "#87CEFA": "Light Sky Blue", "#6A5ACD": "Slate Blue",
                "#B0E0E6": "Powder Blue", "#FFDAB9": "Peach Puff", "#F08080": "Light Coral", "#7CFC00": "Lawn Green",
                "#32CD32": "Lime Green", "#FFC0CB": "Pink", "#9370DB": "Medium Purple", "#A9A9A9": "Dark Gray",
                "#778899": "Light Slate Gray", "#FF6347": "Tomato"
            }), []);

            // --- Utility for drawing pixel art on Canvas with animation ---
            const drawPixelArt = React.useCallback((canvas, concept, palette, animate = true) => {
                const ctx = canvas.getContext('2d');
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const pixelSize = 10;

                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                const effectivePalette = palette.length > 0 ? palette : ['#87CEEB'];
                const backgroundColor = effectivePalette[0];
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const pixelsToDraw = [];

                // Generate abstract pattern pixels
                for (let y = 0; y < canvasHeight; y += pixelSize) {
                    for (let x = 0; x < canvasWidth; x += pixelSize) {
                        const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                        if (Math.random() > 0.6) {
                            pixelsToDraw.push({ x, y, color });
                        }
                    }
                }

                // Generate shape pixels
                const numShapes = Math.floor(Math.random() * 3) + 2;
                for (let i = 0; i < numShapes; i++) {
                    const shapeColor = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                    const startX = Math.floor(Math.random() * (canvasWidth / pixelSize)) * pixelSize;
                    const startY = Math.floor(Math.random() * (canvasHeight / pixelSize)) * pixelSize;
                    const shapeWidth = Math.floor(Math.random() * (canvasWidth / pixelSize / 4) + 1) * pixelSize;
                    const shapeHeight = Math.floor(Math.random() * (canvasHeight / pixelSize / 4) + 1) * pixelSize;

                    if (Math.random() > 0.5) { // Rectangle
                        for (let px = startX; px < startX + shapeWidth; px += pixelSize) {
                            for (let py = startY; py < startY + shapeHeight; py += pixelSize) {
                                pixelsToDraw.push({ x: px, y: py, color: shapeColor, alpha: 0.6 + Math.random() * 0.3 });
                            }
                        }
                    } else { // Approximate circle (large rectangle for pixelated feel)
                         for (let px = startX; px < startX + radius * 2; px += pixelSize) {
                            for (let py = startY; py < startY + radius * 2; py += pixelSize) {
                                pixelsToDraw.push({ x: px, y: py, color: shapeColor, alpha: 0.6 + Math.random() * 0.3 });
                            }
                        }
                    }
                }

                // Shuffle pixels to draw for a more "random" animation effect
                pixelsToDraw.sort(() => Math.random() - 0.5);

                if (animate) {
                    setIsDrawingAnimating(true);
                    let index = 0;
                    // Draw a percentage of pixels per frame, e.g., 5% of total pixels to spread animation
                    const pixelsPerFrame = Math.max(1, Math.floor(pixelsToDraw.length / 20)); // Draw over roughly 20 frames

                    const animateDrawing = () => {
                        const endIndex = Math.min(index + pixelsPerFrame, pixelsToDraw.length);
                        for (let i = index; i < endIndex; i++) {
                            const p = pixelsToDraw[i];
                            ctx.globalAlpha = p.alpha || 1.0;
                            ctx.fillStyle = p.color;
                            ctx.fillRect(p.x, p.y, pixelSize, pixelSize);
                        }
                        index = endIndex;
                        if (index < pixelsToDraw.length) {
                            requestAnimationFrame(animateDrawing);
                        } else {
                            // Animation complete, set final data URL and reset alpha
                            setPixelArtDataUrl(canvas.toDataURL('image/png'));
                            ctx.globalAlpha = 1.0; // Reset global alpha for future drawings
                            setIsDrawingAnimating(false);
                        }
                    };
                    requestAnimationFrame(animateDrawing);
                } else {
                    // No animation, draw all at once
                    pixelsToDraw.forEach(p => {
                        ctx.globalAlpha = p.alpha || 1.0;
                        ctx.fillStyle = p.color;
                        ctx.fillRect(p.x, p.y, pixelSize, pixelSize);
                    });
                    ctx.globalAlpha = 1.0; // Reset alpha
                    setPixelArtDataUrl(canvas.toDataURL('image/png'));
                }
            }, [setIsDrawingAnimating, setPixelArtDataUrl]); // Depend on setters for useCallback


            /**
             * Generates a positive affirmation from a local list.
             */
            const generateAffirmation = React.useCallback(async () => {
                setIsAffirmationLoading(true);
                setAffirmation('');
                setErrorMessage('');

                try {
                    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate delay
                    const randomAffirmation = positiveAffirmations[Math.floor(Math.random() * positiveAffirmations.length)];
                    setAffirmation(randomAffirmation);
                } catch (error) {
                    console.error('Error generating affirmation:', error);
                    setErrorMessage(`Error generating affirmation: ${error.message || 'Something went wrong.'}`);
                } finally {
                    setIsAffirmationLoading(false);
                }
            }, [positiveAffirmations]);

            /**
             * Generates the pixel art concept and palette locally, then draws the art.
             * Now includes mood-based filtering and style filtering.
             */
            const generateArt = React.useCallback(async () => {
                setIsLoading(true); // Start general loading
                setPixelArtDataUrl('');
                setArtDescription('');
                setErrorMessage('');
                setLlmConcept('');
                setLlmPalette([]);

                try {
                    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate initial processing delay

                    let availableArt = positiveArtConceptsAndPalettes;

                    // Feature 4: Filter by selected art style
                    if (selectedArtStyle !== 'All') {
                        availableArt = availableArt.filter(item => item.style === selectedArtStyle);
                    }

                    // Feature 3: Mood-based filtering
                    let filteredArt = [];
                    const lowerCaseMood = moodInput.toLowerCase();

                    if (lowerCaseMood.trim() !== '') {
                        // Find art concepts that match mood keywords
                        filteredArt = availableArt.filter(item =>
                            item.moodTags.some(tag => lowerCaseMood.includes(tag))
                        );
                    }

                    // If no specific mood-matched art or mood input is empty, fallback to general positivity within selected style
                    const finalArtChoices = filteredArt.length > 0 ? filteredArt : availableArt;

                    if (finalArtChoices.length === 0) {
                         setErrorMessage("No art concepts match your mood and selected style. Try a different mood or 'All' styles.");
                         return;
                    }

                    // Select a random concept and palette from the filtered list
                    const randomArtData = finalArtChoices[Math.floor(Math.random() * finalArtChoices.length)];
                    const concept = randomArtData.concept;
                    const palette = randomArtData.palette;

                    setLlmConcept(concept);
                    setLlmPalette(palette);

                    // Step 2: Generate pixel art on canvas using the concept and palette with animation
                    const canvas = canvasRef.current;
                    if (canvas) {
                        // drawPixelArt will handle setting pixelArtDataUrl and setIsDrawingAnimating(false) upon completion
                        drawPixelArt(canvas, concept, palette, true); // Pass true for animation
                    } else {
                        throw new Error('Canvas element not found. This should not happen as canvas is always rendered.');
                    }

                } catch (error) {
                    console.error('Error generating art:', error);
                    setErrorMessage(`Error: ${error.message || 'Something went wrong during art generation. Please try again.'}`);
                } finally {
                    setIsLoading(false); // End general loading (animation handles its own state)
                }
            }, [moodInput, selectedArtStyle, positiveArtConceptsAndPalettes, drawPixelArt]);

            /**
             * Generates a description for the generated art locally.
             */
            const describeArt = React.useCallback(async () => {
                setIsDescriptionLoading(true);
                setArtDescription('');
                setErrorMessage('');

                try {
                    await new Promise(resolve => setTimeout(resolve, 700)); // Simulate delay

                    if (!llmConcept || llmPalette.length === 0) {
                        throw new Error('No art concept or palette available to describe. Please generate art first.');
                    }

                    // Convert HEX codes to color names
                    const colorNames = llmPalette.map(hex => hexToColorName[hex] || hex);
                    
                    const description = `This pixel art is based on the concept: "${llmConcept}". It uses a vibrant palette of colors including ${colorNames.join(', ')}, designed to evoke feelings of positivity and joy.`;
                    setArtDescription(description);

                } catch (error) {
                    console.error('Error describing art:', error);
                    setErrorMessage(`Error describing art: ${error.message || 'Something went wrong.'}`);
                } finally {
                    setIsDescriptionLoading(false);
                }
            }, [llmConcept, llmPalette, hexToColorName]);

            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-100 to-blue-200 flex items-center justify-center p-4 font-sans">
                    <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-2xl text-center border border-gray-200">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6 tracking-tight">
                            Mood-Inspired Pixel Art
                        </h1>
                        <p className="text-gray-600 mb-8 text-lg leading-relaxed">
                            Tell me how you're feeling, and I'll create a unique piece of uplifting pixel art with colors chosen to boost your mood!
                        </p>

                        {/* Mood Input Section */}
                        <div className="mb-6">
                            <label htmlFor="mood" className="block text-gray-700 text-xl font-semibold mb-3">
                                How are you feeling right now?
                            </label>
                            <input
                                id="mood"
                                type="text"
                                value={moodInput}
                                onChange={(e) => setMoodInput(e.target.value)}
                                placeholder="e.g., Anxious, Happy, Tired, Creative..."
                                className="w-full p-4 border border-gray-300 rounded-lg focus:ring-4 focus:ring-blue-300 focus:border-blue-500 transition duration-200 text-lg text-gray-800"
                            />
                        </div>

                        {/* Art Style Selection (Feature 4) */}
                        <div className="mb-8">
                            <label htmlFor="art-style" className="block text-gray-700 text-xl font-semibold mb-3">
                                Choose an Art Style:
                            </label>
                            <select
                                id="art-style"
                                value={selectedArtStyle}
                                onChange={(e) => setSelectedArtStyle(e.target.value)}
                                className="w-full p-4 border border-gray-300 rounded-lg focus:ring-4 focus:ring-purple-300 focus:border-purple-500 transition duration-200 text-lg text-gray-800"
                            >
                                {artStyles.map(style => (
                                    <option key={style} value={style}>{style}</option>
                                ))}
                            </select>
                        </div>


                        {/* Affirmation Button */}
                        <button
                            onClick={generateAffirmation}
                            disabled={isAffirmationLoading || isLoading || !moodInput.trim()}
                            className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mb-4
                                ${isAffirmationLoading
                                    ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-green-500 to-teal-600 text-white shadow-md hover:shadow-lg'
                                }`}
                        >
                            {isAffirmationLoading ? (
                                <span className="flex items-center justify-center">
                                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Generating Affirmation...
                                </span>
                            ) : (
                                '✨ Get Affirmation'
                            )}
                        </button>

                        {/* Display Affirmation */}
                        {affirmation && (
                            <div className="mt-4 mb-6 p-4 bg-blue-50 border border-blue-200 text-blue-800 rounded-lg text-left italic">
                                <p className="font-semibold">Your Affirmation:</p>
                                <p>"{affirmation}"</p>
                            </div>
                        )}

                        {/* Canvas element is now always rendered, but hidden */}
                        <canvas
                            ref={canvasRef}
                            width="400"
                            height="400"
                            style={{ display: 'none' }}
                        ></canvas>

                        {/* Generate Art Button */}
                        <button
                            onClick={generateArt}
                            disabled={isLoading || isDrawingAnimating || !moodInput.trim()}
                            className={`w-full py-4 px-6 rounded-lg text-xl font-bold transition duration-300 ease-in-out transform hover:scale-105
                                ${isLoading || isDrawingAnimating
                                    ? 'bg-gradient-to-r from-gray-400 to-gray-500 text-gray-200 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg hover:shadow-xl'
                                }`}
                        >
                            {(isLoading || isDrawingAnimating) ? (
                                <span className="flex items-center justify-center">
                                    <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    {isDrawingAnimating ? 'Drawing Pixel Art...' : 'Generating Pixel Art Concept...'}
                                </span>
                            ) : (
                                'Generate Uplifting Pixel Art'
                            )}
                        </button>

                        {/* Error Message Display */}
                        {errorMessage && (
                            <div className="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg text-left">
                                <p className="font-semibold">Oops! Something went wrong:</p>
                                <p>{errorMessage}</p>
                            </div>
                        )}

                        {/* Generated Art Display */}
                        {pixelArtDataUrl && (
                            <div className="mt-10 border-t border-gray-200 pt-8">
                                <h2 className="text-3xl font-bold text-gray-800 mb-6">Your Uplifting Pixel Art</h2>
                                <div className="bg-gray-100 p-2 rounded-lg shadow-inner flex justify-center">
                                    <img
                                        src={pixelArtDataUrl}
                                        alt="Generated Pixel Art"
                                        className="w-full h-auto max-w-sm rounded-lg shadow-md image-rendering-pixelated"
                                        style={{ imageRendering: 'pixelated' }}
                                        onError={(e) => {
                                            e.target.onerror = null;
                                            e.target.src = "https://placehold.co/400x400/FF0000/FFFFFF?text=Pixel+Art+Load+Error";
                                            setErrorMessage("Failed to load generated pixel art. It might be corrupted or missing.");
                                        }}
                                    />
                                </div>
                                <p className="text-gray-500 text-sm mt-4">
                                    This art was generated to evoke positive feelings using a palette based on color psychology.
                                </p>

                                {/* Regenerate Button (Feature 6) */}
                                <button
                                    onClick={generateArt}
                                    disabled={isLoading || isDrawingAnimating}
                                    className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mt-6
                                        ${isLoading || isDrawingAnimating
                                            ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                            : 'bg-gradient-to-r from-pink-500 to-red-600 text-white shadow-md hover:shadow-lg'
                                        }`}
                                >
                                    {isLoading || isDrawingAnimating ? (
                                         <span className="flex items-center justify-center">
                                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            {isDrawingAnimating ? 'Drawing New Art...' : 'Generating New Concept...'}
                                        </span>
                                    ) : (
                                        '🔄 Regenerate Art (Same Mood/Style)'
                                    )}
                                </button>

                                {/* Describe Art Button */}
                                <button
                                    onClick={describeArt}
                                    disabled={isDescriptionLoading || isLoading || isDrawingAnimating || !llmConcept || llmPalette.length === 0}
                                    className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mt-4
                                        ${isDescriptionLoading || isLoading || isDrawingAnimating
                                            ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                            : 'bg-gradient-to-r from-indigo-500 to-purple-700 text-white shadow-md hover:shadow-lg'
                                        }`}
                                >
                                    {isDescriptionLoading ? (
                                        <span className="flex items-center justify-center">
                                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Describing Art...
                                        </span>
                                    ) : (
                                        '✨ Describe Pixel Art'
                                    )}
                                </button>

                                {/* Display Art Description */}
                                {artDescription && (
                                    <div className="mt-4 p-4 bg-purple-50 border border-purple-200 text-purple-800 rounded-lg text-left">
                                        <p className="font-semibold">AI Art Description:</p>
                                        <p>{artDescription}</p>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
