<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood-Based Pixel Art Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* This is crucial for maintaining the pixelated look when scaled */
        .image-rendering-pixelated {
            image-rendering: optimizeSpeed;             /* Older versions of FF */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+ */
            image-rendering: -webkit-optimize-contrast; /* Safari, Chrome */
            image-rendering: optimize-contrast;         /* CSS4 */
            image-rendering: pixelated;                 /* CSS4 */
            -ms-interpolation-mode: nearest-neighbor;   /* IE */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // Your React App component starts here
        const App = () => {
            const [moodInput, setMoodInput] = React.useState('');
            const [pixelArtDataUrl, setPixelArtDataUrl] = React.useState(''); // Stores the generated pixel art as a data URL
            const [isLoading, setIsLoading] = React.useState(false);
            const [errorMessage, setErrorMessage] = React.useState('');
            const [affirmation, setAffirmation] = React.useState('');
            const [isAffirmationLoading, setIsAffirmationLoading] = React.useState(false);
            const [llmConcept, setLlmConcept] = React.useState(''); // Stores the concept from "local LLM"
            const [llmPalette, setLlmPalette] = React.useState([]); // Stores the color palette from "local LLM"
            const [artDescription, setArtDescription] = React.useState(''); // New state for art description
            const [isDescriptionLoading, setIsDescriptionLoading] = React.useState(false);

            const canvasRef = React.useRef(null); // Reference to the canvas element

            // --- Predefined Data for Local Generation (replaces API calls) ---

            // Positive affirmations
            const positiveAffirmations = [
                "You are capable of amazing things.",
                "Every day is a new opportunity to shine.",
                "Your strength is greater than any struggle.",
                "Believe in yourself and all that you are.",
                "You are worthy of happiness and success.",
                "Embrace the journey, enjoy the growth.",
                "Today is a gift, that's why it's called the present.",
                "Your potential is limitless.",
                "You are a beacon of positive energy.",
                "Great things are coming your way."
            ];

            // Positive pixel art concepts and associated palettes
            const positiveArtConceptsAndPalettes = [
                {
                    concept: "A vibrant abstract pattern of swirling colors, evoking a sense of light and freedom.",
                    palette: ["#FFD700", "#FFA500", "#87CEEB", "#90EE90", "#FF69B4"] // Gold, Orange, Sky Blue, Light Green, Hot Pink
                },
                {
                    concept: "A serene landscape with a rising sun, bringing warmth and new beginnings.",
                    palette: ["#FFCC33", "#FF9900", "#66CCFF", "#99FF99", "#FFCCCC"] // Golden Yellow, Orange, Light Blue, Mint Green, Light Pink
                },
                {
                    concept: "A cheerful, pixelated garden bursting with happy flowers and bright skies.",
                    palette: ["#FFCC00", "#FF6666", "#66FF66", "#33CCFF", "#FF99CC"] // Yellow, Red-Orange, Bright Green, Cerulean, Pink
                },
                {
                    concept: "An uplifting abstract design with geometric shapes and harmonious gradients.",
                    palette: ["#ADD8E6", "#87CEEB", "#6495ED", "#4682B4", "#7B68EE"] // Light Blue, Sky Blue, Cornflower Blue, Steel Blue, Medium Slate Blue
                },
                {
                    concept: "A playful scene of stars twinkling in a peaceful night sky, full of wonder.",
                    palette: ["#F0E68C", "#DAA520", "#4682B4", "#7B68EE", "#DDA0DD"] // Khaki, Goldenrod, Steel Blue, Medium Slate Blue, Plum
                },
                {
                    concept: "A burst of positive energy, represented by dynamic lines and contrasting bright colors.",
                    palette: ["#FF4500", "#FFD700", "#ADFF2F", "#00BFFF", "#FF1493"] // OrangeRed, Gold, GreenYellow, DeepSkyBlue, DeepPink
                }
            ];

            // Mapping of HEX codes to common color names for descriptions
            const hexToColorName = {
                "#FFD700": "Gold",
                "#FFA500": "Orange",
                "#87CEEB": "Sky Blue",
                "#90EE90": "Light Green",
                "#FF69B4": "Hot Pink",
                "#FFCC33": "Golden Yellow",
                "#FF9900": "Orange", // Duplicate, but good to have explicit mapping
                "#66CCFF": "Light Blue",
                "#99FF99": "Mint Green",
                "#FFCCCC": "Light Pink",
                "#FFCC00": "Yellow",
                "#FF6666": "Red-Orange",
                "#66FF66": "Bright Green",
                "#33CCFF": "Cerulean",
                "#FF99CC": "Pink",
                "#ADD8E6": "Light Blue", // Duplicate
                "#6495ED": "Cornflower Blue",
                "#4682B4": "Steel Blue",
                "#7B68EE": "Medium Slate Blue",
                "#F0E68C": "Khaki",
                "#DAA520": "Goldenrod",
                "#DDA0DD": "Plum",
                "#FF4500": "Orange Red",
                "#ADFF2F": "Green Yellow",
                "#00BFFF": "Deep Sky Blue",
                "#FF1493": "Deep Pink"
            };

            // --- Utility for drawing pixel art on Canvas ---
            const drawPixelArt = (canvas, concept, palette) => {
                const ctx = canvas.getContext('2d');
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const pixelSize = 10; // Size of each "pixel" in the art

                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                // Ensure palette has at least one color for background
                const effectivePalette = palette.length > 0 ? palette : ['#87CEEB']; // Default light blue if palette is empty

                // Background - use a slightly lighter or dominant color from the palette
                const backgroundColor = effectivePalette[0]; // Use first color for background
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Simple abstract pattern generation based on palette
                // Iterate through "super-pixels"
                for (let y = 0; y < canvasHeight; y += pixelSize) {
                    for (let x = 0; x < canvasWidth; x += pixelSize) {
                        // Randomly pick a color from the palette
                        const color = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                        ctx.fillStyle = color;

                        // Apply a random chance to draw, creating sparse or dense patterns
                        if (Math.random() > 0.6) { // Draw a pixel with 40% chance
                            ctx.fillRect(x, y, pixelSize, pixelSize);
                        }
                    }
                }

                // Add some larger, more prominent abstract shapes/swirls
                const numShapes = Math.floor(Math.random() * 3) + 2; // 2 to 4 shapes
                for (let i = 0; i < numShapes; i++) {
                    const shapeColor = effectivePalette[Math.floor(Math.random() * effectivePalette.length)];
                    ctx.fillStyle = shapeColor;
                    ctx.globalAlpha = 0.6 + Math.random() * 0.3; // Semi-transparent

                    const startX = Math.floor(Math.random() * (canvasWidth / pixelSize)) * pixelSize;
                    const startY = Math.floor(Math.random() * (canvasHeight / pixelSize)) * pixelSize;
                    const shapeWidth = Math.floor(Math.random() * (canvasWidth / pixelSize / 4) + 1) * pixelSize; // Max 1/4th width
                    const shapeHeight = Math.floor(Math.random() * (canvasHeight / pixelSize / 4) + 1) * pixelSize; // Max 1/4th height

                    if (Math.random() > 0.5) { // Draw a rectangle
                        ctx.fillRect(startX, startY, shapeWidth, shapeHeight);
                    } else { // Draw a "circle" (approximated by pixel blocks)
                        const radius = Math.min(shapeWidth, shapeHeight) / 2;
                        ctx.beginPath();
                        // Drawing a pixelated circle is complex; simplest is a large rectangle
                        // or a series of concentric squares reducing in size
                        ctx.fillRect(startX, startY, radius * 2, radius * 2);
                    }
                }
                ctx.globalAlpha = 1.0; // Reset alpha

                // Convert canvas content to a data URL
                return canvas.toDataURL('image/png');
            };

            /**
             * Generates a positive affirmation from a local list.
             */
            const generateAffirmation = async () => {
                setIsAffirmationLoading(true);
                setAffirmation('');
                setErrorMessage('');

                try {
                    // Simulate API call delay
                    await new Promise(resolve => setTimeout(resolve, 500));

                    const randomAffirmation = positiveAffirmations[Math.floor(Math.random() * positiveAffirmations.length)];
                    setAffirmation(randomAffirmation);

                } catch (error) {
                    console.error('Error generating affirmation:', error);
                    setErrorMessage(`Error generating affirmation: ${error.message || 'Something went wrong.'}`);
                } finally {
                    setIsAffirmationLoading(false);
                }
            };


            /**
             * Generates the pixel art concept and palette locally, then draws the art.
             */
            const generateArt = async () => {
                setIsLoading(true);
                setPixelArtDataUrl('');
                setArtDescription('');
                setErrorMessage('');
                setLlmConcept('');
                setLlmPalette([]);

                try {
                    // Simulate API call delay
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // Step 1: Locally determine concept and palette based on mood (simplified)
                    // For a more advanced local version, you could map keywords in moodInput
                    // to specific concepts/palettes. For now, we'll pick randomly.
                    const randomArtData = positiveArtConceptsAndPalettes[Math.floor(Math.random() * positiveArtConceptsAndPalettes.length)];
                    const concept = randomArtData.concept;
                    const palette = randomArtData.palette;

                    setLlmConcept(concept);
                    setLlmPalette(palette);

                    // Step 2: Generate pixel art on canvas using the concept and palette
                    const canvas = canvasRef.current;
                    if (canvas) {
                        const dataUrl = drawPixelArt(canvas, concept, palette);
                        setPixelArtDataUrl(dataUrl);
                    } else {
                        throw new Error('Canvas element not found. This should not happen as canvas is always rendered.');
                    }

                } catch (error) {
                    console.error('Error generating art:', error);
                    setErrorMessage(`Error: ${error.message || 'Something went wrong during art generation. Please try again.'}`);
                } finally {
                    setIsLoading(false);
                }
            };

            /**
             * Generates a description for the generated art locally.
             */
            const describeArt = async () => {
                setIsDescriptionLoading(true);
                setArtDescription('');
                setErrorMessage('');

                try {
                    // Simulate API call delay
                    await new Promise(resolve => setTimeout(resolve, 700));

                    if (!llmConcept || llmPalette.length === 0) {
                        throw new Error('No art concept or palette available to describe. Please generate art first.');
                    }

                    // Convert HEX codes to color names
                    const colorNames = llmPalette.map(hex => hexToColorName[hex] || hex); // Fallback to HEX if name not found
                    
                    // Generate a simple description based on the stored concept and palette
                    const description = `This pixel art is based on the concept: "${llmConcept}". It uses a vibrant palette of colors including ${colorNames.join(', ')}, designed to evoke feelings of positivity and joy.`;
                    setArtDescription(description);

                } catch (error) {
                    console.error('Error describing art:', error);
                    setErrorMessage(`Error describing art: ${error.message || 'Something went wrong.'}`);
                } finally {
                    setIsDescriptionLoading(false);
                }
            };


            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-100 to-blue-200 flex items-center justify-center p-4 font-sans">
                    <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-2xl text-center border border-gray-200">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6 tracking-tight">
                            Mood-Inspired Pixel Art
                        </h1>
                        <p className="text-gray-600 mb-8 text-lg leading-relaxed">
                            Tell me how you're feeling, and I'll create a unique piece of uplifting pixel art with colors chosen to boost your mood!
                        </p>

                        {/* Mood Input Section */}
                        <div className="mb-8">
                            <label htmlFor="mood" className="block text-gray-700 text-xl font-semibold mb-3">
                                How are you feeling right now?
                            </label>
                            <input
                                id="mood"
                                type="text"
                                value={moodInput}
                                onChange={(e) => setMoodInput(e.target.value)}
                                placeholder="e.g., Anxious, Happy, Tired, Creative..."
                                className="w-full p-4 border border-gray-300 rounded-lg focus:ring-4 focus:ring-blue-300 focus:border-blue-500 transition duration-200 text-lg text-gray-800"
                            />
                        </div>

                        {/* Affirmation Button */}
                        <button
                            onClick={generateAffirmation}
                            disabled={isAffirmationLoading || !moodInput.trim()}
                            className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mb-4
                                ${isAffirmationLoading
                                    ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-green-500 to-teal-600 text-white shadow-md hover:shadow-lg'
                                }`}
                        >
                            {isAffirmationLoading ? (
                                <span className="flex items-center justify-center">
                                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Generating Affirmation...
                                </span>
                            ) : (
                                '✨ Get Affirmation'
                            )}
                        </button>

                        {/* Display Affirmation */}
                        {affirmation && (
                            <div className="mt-4 mb-6 p-4 bg-blue-50 border border-blue-200 text-blue-800 rounded-lg text-left italic">
                                <p className="font-semibold">Your Affirmation:</p>
                                <p>"{affirmation}"</p>
                            </div>
                        )}

                        {/* Canvas element is now always rendered, but hidden */}
                        <canvas
                            ref={canvasRef}
                            width="400"
                            height="400"
                            style={{ display: 'none' }}
                        ></canvas>

                        {/* Generate Art Button */}
                        <button
                            onClick={generateArt}
                            disabled={isLoading || !moodInput.trim()}
                            className={`w-full py-4 px-6 rounded-lg text-xl font-bold transition duration-300 ease-in-out transform hover:scale-105
                                ${isLoading
                                    ? 'bg-gradient-to-r from-gray-400 to-gray-500 text-gray-200 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg hover:shadow-xl'
                                }`}
                        >
                            {isLoading ? (
                                <span className="flex items-center justify-center">
                                    <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    Generating Pixel Art...
                                </span>
                            ) : (
                                'Generate Uplifting Pixel Art'
                            )}
                        </button>

                        {/* Error Message Display */}
                        {errorMessage && (
                            <div className="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg text-left">
                                <p className="font-semibold">Oops! Something went wrong:</p>
                                <p>{errorMessage}</p>
                            </div>
                        )}

                        {/* Generated Art Display */}
                        {pixelArtDataUrl && (
                            <div className="mt-10 border-t border-gray-200 pt-8">
                                <h2 className="text-3xl font-bold text-gray-800 mb-6">Your Uplifting Pixel Art</h2>
                                <div className="bg-gray-100 p-2 rounded-lg shadow-inner flex justify-center">
                                    <img
                                        src={pixelArtDataUrl}
                                        alt="Generated Pixel Art"
                                        className="w-full h-auto max-w-sm rounded-lg shadow-md image-rendering-pixelated" // CSS for pixelation
                                        style={{ imageRendering: 'pixelated' }} // Ensure pixelated look
                                        onError={(e) => {
                                            e.target.onerror = null;
                                            e.target.src = "https://placehold.co/400x400/FF0000/FFFFFF?text=Pixel+Art+Load+Error";
                                            setErrorMessage("Failed to load generated pixel art. It might be corrupted or missing.");
                                        }}
                                    />
                                </div>
                                <p className="text-gray-500 text-sm mt-4">
                                    This art was generated to evoke positive feelings using a palette based on color psychology.
                                </p>

                                {/* Describe Art Button */}
                                <button
                                    onClick={describeArt}
                                    disabled={isDescriptionLoading || !llmConcept || llmPalette.length === 0}
                                    className={`w-full py-3 px-6 rounded-lg text-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 mt-6
                                        ${isDescriptionLoading
                                            ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-gray-100 cursor-not-allowed'
                                            : 'bg-gradient-to-r from-indigo-500 to-purple-700 text-white shadow-md hover:shadow-lg'
                                        }`}
                                >
                                    {isDescriptionLoading ? (
                                        <span className="flex items-center justify-center">
                                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Describing Art...
                                        </span>
                                    ) : (
                                        '✨ Describe Pixel Art'
                                    )}
                                </button>

                                {/* Display Art Description */}
                                {artDescription && (
                                    <div className="mt-4 p-4 bg-purple-50 border border-purple-200 text-purple-800 rounded-lg text-left">
                                        <p className="font-semibold">AI Art Description:</p>
                                        <p>{artDescription}</p>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
